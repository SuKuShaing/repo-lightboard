<canvas id="lienzo"></canvas>

<style>
	canvas {
		position: fixed;
		top: 0;
		left: 0;
		z-index: -1;
		/* width: 100%; */
		/* height: 100%; */
		/* background-color: transparent; */
        opacity: 1;
	}
</style>

<script>
	/*───────── una vez cargada la web se ejecute ─────────*/
	function estoyListo() {
		/*───────── CONFIGURACIÓN GENERAL ─────────*/
		const NUM_LINES = 3;                    // número de líneas a la vez, optimo 3
		const POINTS = 20;                      // puntos del cuerpo de la línea
		const SEGMENT_FRAC = 0.2;               // largo de la línea, fracción de segmento
		const BORDER_WIDTH = 10;                // grosor del borde color
		const CORE_WIDTH = BORDER_WIDTH / 3;    // grosor núcleo blanco
		const GLOW_BLUR = 20;                   // desenfoque del halo
		const SPEED_MIN = 0.00003;              // velocidad mínima de la línea, velocidad original 0.0001
		const SPEED_MAX = 0.00010;              // velocidad máxima de la línea, velocidad original 0.0004
		// const AMPLITUDE = 1;                 // amplitud de la onda -> se puede sacar
		// const NOISE_SPEED = 0.0002;          // velocidad del ruido, velocidad original 0.002 -> se puede sacar

		/* % de líneas que serán SOLO UNA curva Bézier */
		const SINGLE_CHANCE = 0.6; // 60 % simples, 40 % dobles

		const SIDES = ["left", "right", "top", "bottom"];
		const palette = ["#0f0", "#f0f", "#f00", "#0ff", "#ff0", "#f80", "#fff", "#0004ff", "#8f00ff"];

		/*───────── CANVAS ─────────*/
		const canvas = document.getElementById("lienzo") as HTMLCanvasElement;
		const ctx = canvas.getContext("2d") as CanvasRenderingContext2D;
		const resize = () => {
			canvas.width = innerWidth;
			canvas.height = innerHeight;
		};
		addEventListener("resize", resize);		// Sí escucho el evento de resize, cambia el tamaño del canvas
		resize();

		/*───────── INTERFAZ ─────────*/
		interface Line {
			simple: boolean;
			A: Punto;
			B1: Punto;
			C1: Punto;
			D: Punto;
			M: Punto | null;
			B2: Punto | null;
			C2: Punto | null;
			pts: PropiedadesPunto[];
			color: string;
			u: number;
		};

		interface Punto {
			x: number;
			y: number;
		};

		interface PropiedadesPunto {
			t: number;
			offset: number;
		}

		/*───────── PERLIN SIMPLE ─────────*/
		/*
		const perm = new Uint8Array(512);
		(() => {
			const p = Uint8Array.from({ length: 256 }, (_, i) => i);
			for (let i = 255; i; i--) {
				const j = (Math.random() * (i + 1)) | 0;
				[p[i], p[j]] = [p[j], p[i]];
			}
			for (let i = 0; i < 512; i++) perm[i] = p[i & 255];
		})();
		const fade = (t: number): number => t * t * t * (t * (t * 6 - 15) + 10);
		const lerp = (a: number, b: number, t: number): number => a + t * (b - a);
		const grad = (h: number, x: number, y: number): number => (h & 1 ? -x : x) + (h & 2 ? -2 * y : 2 * y);
		
		function perlin2D(x: number, y: number): number {
			/* El Perlin Noise (ruido de Perlin) es un tipo de ruido gradiente que genera valores pseudoaleatorios suaves y naturales
			*  x: que es p.offset (cambia con el tiempo)
			*  y: que es i * 10 (posición a lo largo de la línea)
			*  Genera un valor de ruido que:
			*  - Es consistente (los mismos inputs siempre dan los mismos outputs)
			*  - Es suave (no hay cambios bruscos entre valores cercanos)
			*  - Parece aleatorio pero tiene una apariencia natural
			
			const X = (x | 0) & 255,
				Y = (y | 0) & 255,
				xf = x - (x | 0),
				yf = y - (y | 0),
				u = fade(xf),
				v = fade(yf),
				aa = perm[X + perm[Y]],
				ab = perm[X + perm[Y + 1]],
				ba = perm[X + 1 + perm[Y]],
				bb = perm[X + 1 + perm[Y + 1]],
				x1 = lerp(grad(aa, xf, yf), grad(ba, xf - 1, yf), u),
				x2 = lerp(grad(ab, xf, yf - 1), grad(bb, xf - 1, yf - 1), u);
			return lerp(x1, x2, v);
		}
		*/
		/*───────── BÉZIER CÚBICA ─────────*/
		const cubic = (P0: Punto, P1: Punto, P2: Punto, P3: Punto, t: number): Punto => {
			/* Dado los puntos P0, P1, P2, P3, se calcula la posición del punto Q(t) en la curva Bézier cúbica
			 *  t es un valor entre 0 y 1 que representa la posición relativa dentro de la curva Bézier
			 *  P0, P1, P2, P3 son los puntos de control de la curva Bézier
			 *  P0 es el punto inicial de la curva Bézier
			 *  P1 es el primer punto de control de la curva Bézier
			 *  P2 es el segundo punto de control de la curva Bézier
			 *  P3 es el punto final de la curva Bézier
			 *  u = 1 - t es el complemento de t, es decir, el valor que falta para llegar a 1
			 *  u * u * u es el cubo de u, es decir, u elevado a la potencia 3
			 *  u * u * t es el cuadrado de u por t, es decir, u elevado a la potencia 2 por t
			 *  t * t * t es el cubo de t, es decir, t elevado a la potencia 3
			 *  B(t) = (1-t)³P0 + 3(1-t)²tP1 + 3(1-t)t²P2 + t³P3
			 */
			const u = 1 - t; // complemento de t, es decir, el valor que falta para llegar a 1
			return {
				x:
					u * u * u * P0.x +
					3 * u * u * t * P1.x +
					3 * u * t * t * P2.x +
					t * t * t * P3.x,
				y:
					u * u * u * P0.y +
					3 * u * u * t * P1.y +
					3 * u * t * t * P2.y +
					t * t * t * P3.y,
			};
		};

		/*
		const cubicDer = (P0: Punto, P1: Punto, P2: Punto, P3: Punto, t: number): Punto => {
			/* Dado los puntos P0, P1, P2, P3, se calcula la derivada de la curva Bézier cúbica
			*  para obtener el vector tangente a la curva Bézier en el punto Q(t)
			*  que nos indica la dirección de la línea
			const u = 1 - t;
			return {
				x:
					3 * u * u * (P1.x - P0.x) +
					6 * u * t * (P2.x - P1.x) +
					3 * t * t * (P3.x - P2.x),
				y:
					3 * u * u * (P1.y - P0.y) +
					6 * u * t * (P2.y - P1.y) +
					3 * t * t * (P3.y - P2.y),
			};
		};
		*/

		/*───────── EVALUAR TRAZADOS ─────────*/
		function evalCurve(line: Line, t: number): Punto {		// Evalúa sí la curva es simple o doble y según eso pide el la posición dando los puntos de control
			// responde con la posición del punto en la curva Bézier

			// Línea simple
			if (line.simple) {
				return cubic(line.A, line.B1, line.C1, line.D, t);
			}
			// Línea doble, al ser doble, se divide en 2 partes el recorrido, la primera parte es la curva de la línea simple, la segunda parte otra curva bézier unida al final de la primera
			if (!line.M || !line.B2 || !line.C2) {
				throw new Error("Puntos de control faltantes para línea doble");
			}
			if (t < 0.5) {
				// La primera parte de la línea doble
				return cubic(line.A, line.B1, line.C1, line.M, t * 2);
			}
			// La segunda parte de la línea doble
			return cubic(line.M, line.B2, line.C2, line.D, (t - 0.5) * 2);
		}

		/*
		function evalDeriv(line: Line, t: number): Punto {		// Evalúa sí la curva es simple o doble y según eso pide el la posición dando los puntos de control
			// responde con el vector tangente a la curva Bézier en el punto Q(t)

			if (line.simple) {
				return cubicDer(line.A, line.B1, line.C1, line.D, t);
			}

			if (!line.M || !line.B2 || !line.C2) {
				throw new Error("Puntos de control faltantes para línea doble");
			}

			if (t < 0.5) {
				return cubicDer(line.A, line.B1, line.C1, line.M, t * 2);
			}
			return cubicDer(line.M, line.B2, line.C2, line.D, (t - 0.5) * 2);
		}
		*/

		/*───────── GENERAR LÍNEA ─────────*/
		const pickSide = (ladoExcluido: string): string => { 	// Función que elige un lado azar
			const o = SIDES.filter((s) => s !== ladoExcluido);	// Filtra los lados que no sean el lado inicial
			return o[(Math.random() * o.length) | 0]; 			// Devuelve un lado al azar entre los ya filtrados
			// 2,36737 | 0 = 2, porque al comparar con el 0, forzamos la conversión a entero de 32 bits y compara el entero 2 con 0 y ahí hace la elección, número entero o cero, es más rápido que hacer un Math.floor()
		};

		const randOut = (side: string): { x: number, y: number } => {		// Elige un punto al azar según el lado dado
			if (side === "left") {
				return { x: -0.1, y: Math.random() };
			} else if (side === "right") {
				return { x: 1.1, y: Math.random() };
			} else if (side === "top") {
				return { x: Math.random(), y: -0.1 };
			} else {
				return { x: Math.random(), y: 1.1 };
			}
		};

		function initLine() {
			const inS = pickSide('')							// Pide un lado inicial al azar
			const outS = pickSide(inS)							// Pide un lado final al azar

			/* Puntos para la curva Bézier */
			const A = randOut(inS)								// Pide un punto al azar en el lado inicial
			const D = randOut(outS)								// Pide un punto al azar en el lado final
			const B1 = { x: Math.random(), y: Math.random() };	// Elige un punto intermedio al azar
			const C1 = { x: Math.random(), y: Math.random() };	// Elige un punto intermedio al azar

			const simple = Math.random() < SINGLE_CHANCE;		// Decide si es una curva simple o doble

			/* puntos extra sólo si es doble curva */
			const M = simple ? null : { x: Math.random(), y: Math.random() };
			const B2 = simple ? null : { x: Math.random(), y: Math.random() };
			const C2 = simple ? null : { x: Math.random(), y: Math.random() };

			return {
				simple,
				A,
				B1,
				C1,
				M,
				B2,
				C2,
				D,
				speed: SPEED_MIN + Math.random() * (SPEED_MAX - SPEED_MIN),		// Elige la velocidad
				pts: Array.from({ length: POINTS }, (_, i) => ({  				// el _ es un parámetro que no se usa, se puede llamar como se quiera
					t: i / (POINTS - 1), 										// valores entre 0 y 1 distribuidos de forma uniforme, para la curva Bézier, 0 = inicio, 1 = fin
					offset: Math.random() * 1000, 								// para darle la ondulación interna a la línea, la que al final apacigüe, podría sacarlo
				})),
				color: palette[(Math.random() * palette.length) | 0],			// Elige un color al azar
				u: -SEGMENT_FRAC * 2 * Math.random(),							// qué tan tras parte, parte 2 veces atrás de su tamaño, el Math.random() es para darle distintos tamaños a las líneas
				/* u = 0 significa que la línea está completamente visible
				*  u = 1 significa que la línea ha completado su recorrido
				*  u negativo significa que la línea aún no ha entrado completamente en la pantalla 
				*  u mayor a 1 significa que la línea ha salido completamente de la pantalla*/
			};
		};

		const lines = Array.from({ length: NUM_LINES }, initLine);	// Crea un array con las propiedades que van a tener las líneas, NUM_LINES (número de líneas) veces, cada vez que se llama a initLine, se crea una nueva línea y se agrega al array

		/*───────── DIBUJO / ANIMACIÓN ─────────*/
		let last: number = 0;
		function draw(now: number): void {
			const dt = now - last; // now es proporcionado por el método requestAnimationFrame(), es el tiempo actual en milisegundos, last es el tiempo de la última vez que se ejecutó la función, dt es la diferencia de tiempo entre la última vez y la actual
			last = now;
			ctx.clearRect(0, 0, canvas.width, canvas.height);

			lines.forEach((line) => {
				line.u += line.speed * dt;
				if (line.u > 1 + SEGMENT_FRAC) Object.assign(line, initLine()); // si la línea ha completado su recorrido y ha salido completamente de la vista, se reinicia
				// Object.assign() copia todas estas nuevas propiedades sobre la línea existente, efectivamente "reciclándola"

				const u0 = line.u - SEGMENT_FRAC; 	// u0 es el punto inicial de la línea, cabeza
				const u1 = line.u; 					// u1 es el punto final de la línea, cola

				ctx.beginPath();
				let px: number = 0;
				let py: number = 0;
				line.pts.forEach((p, i) => {
					const tt = Math.max(0, Math.min(1, u0 + p.t * (u1 - u0)));
					/* u0 + p.t * (u1 - u0) es una interpolación lineal entre u0 y u1
					*  p.t es un valor entre 0 y 1 que representa la posición relativa de cada punto dentro de la línea
					*  u0 es el punto inicial de la línea, cabeza
					*  u1 es el punto final de la línea, cola
					*  Math.min(1, ...): Limita el valor máximo a 1, evitando que se pase del final de la curva
					*  Math.max(0, ...): Limita el valor mínimo a 0, evitando que se pase del inicio de la curva
					*  tt  es un valor entre 0 y 1 que representa la posición exacta en la curva Bézier donde debe evaluarse cada punto individual de la línea de luz
					*/
					const Q = evalCurve(line, tt);		// obtiene la posición del punto en la curva Bézier

					/* Comenté estas lineas porque al final no ocupé el zigzagueo de la línea, solo la curva Bézier */
					// const d = evalDeriv(line, tt);		// obtiene el vector tangente a la curva Bézier en el punto Q, que me dice dirección de la línea
					// const dx = d.x * canvas.width;		// componente x del vector tangente
					// const dy = d.y * canvas.height;		// componente y del vector tangente
					// const L = Math.hypot(dx, dy) || 1;	// longitud del vector tangente, Math.hypot() es la hipotenusa de los catetos dx y dy
					// const nx = -dy / L;					// es la componente x del vector normal unitario, el vector normal es perpendicular (hacia afuera del plano) al vector tangente
					// const ny = dx / L;					// es la componente y del vector normal unitario, el vector normal es perpendicular (hacia afuera del plano) al vector tangente
					// p.offset += dt * NOISE_SPEED;		// Mueve el offset según la velocidad del ruido y la diferencia de tiempo entre un fotograma y el anterior
					// const n = perlin2D(p.offset, i * 10) * AMPLITUDE;	// calcula el valor de ruido para el punto actual

					const X = Q.x * canvas.width;					// calcula la posición en el plano del punto en la línea de luz, original X = Q.x * canvas.width + nx * n;
					const Y = Q.y * canvas.height;					// calcula la posición en el plano del punto en la línea de luz, original Y = Q.y * canvas.height + ny * n;
					if (i === 0) ctx.moveTo(X, Y); 					// si es el primer punto, se mueve al punto
					else {											// si no, se dibuja una curva Bézier
						const midX = (px + X) / 2;					// calcula el punto medio entre el punto actual y el siguiente
						const midY = (py + Y) / 2;					// calcula el punto medio entre el punto actual y el siguiente
						ctx.quadraticCurveTo(px, py, midX, midY);	// dibuja una curva cuadrática para un efecto de suavizado entre un punto y el otro
					}
					px = X;							// actualiza el punto actual
					py = Y;							// actualiza el punto actual
				});
				ctx.lineTo(px, py);					// dibuja la línea desde el último punto hasta el punto actual, solo para el último punto

				/* borde coloreado + halo */
				ctx.lineCap = "round";			// redondea los extremos de la línea
				ctx.lineJoin = "round";			// redondea los ángulos de la línea
				ctx.lineWidth = BORDER_WIDTH;	// grosor del borde de la línea
				ctx.strokeStyle = line.color;	// color del borde de la línea
				ctx.shadowColor = line.color;	// color del halo de la línea
				ctx.shadowBlur = GLOW_BLUR;		// desenfoque del halo de la línea
				ctx.stroke();

				/* núcleo blanco */
				ctx.lineWidth = CORE_WIDTH;		// grosor del núcleo de la línea
				ctx.shadowBlur = 0;				// desenfoque del núcleo de la línea
				ctx.strokeStyle = "#fff";		// color del núcleo de la línea
				ctx.stroke();
			});

			requestAnimationFrame(draw);
		}
		requestAnimationFrame(draw); 
		// método del objeto window y API del navegador, está específicamente diseñada para crear animaciones optimizadas, sincroniza la petición de animación con el refresco de la pantalla, pausa la animación cuando el usuario cambia de pestaña o minimiza la ventana.
	}

	document.addEventListener("DOMContentLoaded", () => {
		setTimeout(estoyListo, 1000);
	});
</script>
